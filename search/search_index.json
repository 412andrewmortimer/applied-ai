{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcc2 Applied AI Study Docs","text":"<p>This repository organizes notes for my Applied AI Master's coursework using MkDocs.</p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>\ud83d\udce6 applied-ai-masters-notes\n\u2523 \ud83d\udcc2 docs\n\u2503 \u2523 \ud83d\udcc2 courses\n\u2503 \u2503 \u2523 \ud83d\udcc2 intro-to-ai\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc index.md\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc syllabus.md\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc lectures.md\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc assignments.md\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc exam-prep.md\n\u2503 \u2503 \u2503 \u2517 \ud83d\udcdc references.md\n\u2503 \u2503 \u2517 \ud83d\udcc2 future-courses\n\u2503 \u2523 \ud83d\udcc2 resources\n\u2503 \u2503 \u2523 \ud83d\udcdc textbooks.md\n\u2503 \u2503 \u2523 \ud83d\udcdc useful-links.md\n\u2503 \u2503 \u2517 \ud83d\udcdc research-papers.md\n\u2503 \u2523 \ud83d\udcdc index.md  \u2190 (Home Page)\n\u2523 \ud83d\udcdc mkdocs.yml  \u2190 (MkDocs site configuration)\n\u2523 \ud83d\udcdc README.md  \u2190 (GitHub repo overview)\n\u2523 \ud83d\udcdc requirements.txt  \u2190 (Python dependencies)\n\u2523 \ud83d\udcc2 assets  \u2190 (Images, PDFs, etc.)\n\u2517 \ud83d\udcc2 .github (GitHub Actions for automation)\n</code></pre>"},{"location":"courses/","title":"\ud83d\udcc2 Applied AI Study Docs","text":"<p>This repository organizes notes for my Applied AI Master's coursework using MkDocs.</p>"},{"location":"courses/#project-layout","title":"Project layout","text":"<pre><code>\ud83d\udce6 applied-ai-masters-notes\n\u2523 \ud83d\udcc2 docs\n\u2503 \u2523 \ud83d\udcc2 courses\n\u2503 \u2503 \u2523 \ud83d\udcc2 intro-to-ai\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc index.md\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc syllabus.md\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc lectures.md\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc assignments.md\n\u2503 \u2503 \u2503 \u2523 \ud83d\udcdc exam-prep.md\n\u2503 \u2503 \u2503 \u2517 \ud83d\udcdc references.md\n\u2503 \u2503 \u2517 \ud83d\udcc2 future-courses\n\u2503 \u2523 \ud83d\udcc2 resources\n\u2503 \u2503 \u2523 \ud83d\udcdc textbooks.md\n\u2503 \u2503 \u2523 \ud83d\udcdc useful-links.md\n\u2503 \u2503 \u2517 \ud83d\udcdc research-papers.md\n\u2503 \u2523 \ud83d\udcdc index.md  \u2190 (Home Page)\n\u2523 \ud83d\udcdc mkdocs.yml  \u2190 (MkDocs site configuration)\n\u2523 \ud83d\udcdc README.md  \u2190 (GitHub repo overview)\n\u2523 \ud83d\udcdc requirements.txt  \u2190 (Python dependencies)\n\u2523 \ud83d\udcc2 assets  \u2190 (Images, PDFs, etc.)\n\u2517 \ud83d\udcc2 .github (GitHub Actions for automation)\n</code></pre>"},{"location":"courses/intro-to-ai/chapter2/agents-and-environments/","title":"2.1 Agents and Environments","text":""},{"location":"courses/intro-to-ai/chapter2/agents-and-environments/#overview","title":"Overview","text":"<p>An agent is an entity that perceives its environment through sensors and acts upon the environment through actuators. The interaction between agents and environments is central to the study of artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter2/agents-and-environments/#key-concepts","title":"Key Concepts","text":""},{"location":"courses/intro-to-ai/chapter2/agents-and-environments/#agent","title":"Agent","text":"<ul> <li>An agent is defined by:</li> <li>Sensors: Devices or components that perceive the environment.</li> <li> <p>Actuators: Devices or components that affect the environment through actions.</p> </li> <li> <p>Agent Function: A mapping from percept sequences to actions:</p> </li> <li> <p>Agent Program: The implementation of the agent function that runs on a physical device (architecture).</p> </li> </ul>"},{"location":"courses/intro-to-ai/chapter2/agents-and-environments/#environment","title":"Environment","text":"<ul> <li>The environment is the external world that the agent interacts with.</li> <li>The environment provides percepts to the agent via sensors and receives actions via actuators.</li> </ul>"},{"location":"courses/intro-to-ai/chapter2/agents-and-environments/#agent-environment-interaction","title":"Agent-Environment Interaction","text":"<ul> <li>Interaction can be visualized as:</li> </ul> <p>Example</p> <pre><code>sequenceDiagram\nparticipant Environment\nparticipant Sensors\nparticipant Agent\nparticipant Actuators\n\nEnvironment-&gt;&gt;Sensors: Generate percepts\nSensors-&gt;&gt;Agent: Pass percepts to Agent Program\nAgent-&gt;&gt;Agent: Process percept sequence\nAgent-&gt;&gt;Actuators: Select action\nActuators-&gt;&gt;Environment: Execute action</code></pre> <p>Info</p> <p>Agent \u2192 Sensors \u2192 Percepts \u2192 Environment \u2192 Actions \u2192 Actuators \u2192 Agent</p>"},{"location":"courses/intro-to-ai/chapter2/agents-and-environments/#examples-of-agents","title":"Examples of Agents","text":"Agent Sensors Actuators Environment Self-Driving Car Cameras, GPS, LIDAR Steering, Brakes Roads, Traffic Medical Diagnosis System Keyboards, Scanners Recommendations Medical Records, Patients Robotic Vacuum IR Sensors, Cameras Wheels, Suction Home, Floors"},{"location":"courses/intro-to-ai/chapter2/agents-and-environments/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Agents use sensors to perceive the environment and actuators to perform actions.</li> <li>Percept Sequence: The entire history of percepts received by the agent.</li> <li>Rationality: The concept of rational agents is based on their ability to take actions that maximize performance, given what they perceive and know.</li> <li>Agent Design: Agents are implemented as programs running on physical architectures.</li> </ol> <p>This section establishes the fundamental relationship between agents and their environments, laying the groundwork for designing intelligent systems.</p>"},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/","title":"2.0 Intelligent Agents","text":""},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/#overview","title":"Overview","text":"<p>This chapter explores the foundational concept of intelligent agents by focusing on their nature, the environments they operate in, and the principles for designing effective agents.</p>"},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/#key-highlights","title":"Key Highlights","text":""},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/#1-rational-agents","title":"1. Rational Agents","text":"<ul> <li>Builds on the idea introduced in Chapter 1, emphasizing rational agents as central to artificial intelligence.</li> <li>A rational agent takes the best possible action to maximize performance, given its knowledge, percepts, and the nature of the environment.</li> </ul>"},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/#2-agents-and-environments","title":"2. Agents and Environments","text":"<ul> <li>Agents are entities that interact with their environment through sensors (to perceive) and actuators (to act).</li> <li>Environment: The external system or world in which the agent operates.</li> <li>The interaction between agents and environments forms the basis of intelligent behavior.</li> </ul>"},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/#3-performance-and-rationality","title":"3. Performance and Rationality","text":"<ul> <li>Agent performance is evaluated based on a performance measure.</li> <li>Rationality depends on:</li> <li>The agent\u2019s goals.</li> <li>Knowledge of the environment.</li> <li>Actions available to the agent.</li> <li>Characteristics of the environment.</li> </ul>"},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/#4-categorization-of-environments","title":"4. Categorization of Environments","text":"<ul> <li>Environments are classified based on their complexity:</li> <li>Fully Observable vs. Partially Observable.</li> <li>Deterministic vs. Stochastic.</li> <li>Static vs. Dynamic.</li> <li>Episodic vs. Sequential.</li> <li>Discrete vs. Continuous.</li> <li>Known vs. Unknown.</li> <li>This categorization helps determine the type of agent needed for a specific environment.</li> </ul>"},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/#5-agent-design","title":"5. Agent Design","text":"<ul> <li>The chapter introduces basic agent designs or \"skeletons\":</li> <li>Simple Reflex Agents: Act based only on the current percept.</li> <li>Model-Based Reflex Agents: Maintain an internal model of the environment.</li> <li>Goal-Based Agents: Use goals to decide actions.</li> <li>Utility-Based Agents: Optimize actions based on a utility function.</li> <li>Learning Agents: Improve performance over time by learning from experience.</li> </ul>"},{"location":"courses/intro-to-ai/chapter2/intelligent-agents/#core-takeaways","title":"Core Takeaways","text":"<ol> <li>The concept of rationality applies universally to all types of agents in diverse environments.</li> <li>The design principles for agents involve balancing complexity and capability to achieve rational behavior.</li> <li>Understanding the properties of the environment is essential for creating effective agents.</li> </ol> <p>This chapter establishes the framework for analyzing agents and their interactions with environments, forming the foundation for designing intelligent systems. The rest of the book expands on these principles with specific techniques and applications.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/","title":"\ud83d\udcd6 5.2.1 The Minimax Search Algorithm","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>The Minimax Algorithm is a fundamental technique used in two-player zero-sum games where both players play optimally. The algorithm assumes: - One player (MAX) tries to maximize the game\u2019s outcome. - The opponent (MIN) tries to minimize MAX\u2019s best possible outcome. - Both players take turns, and the game follows a tree-like structure where each move leads to a different game state.</p> <p>Minimax is used in turn-based, deterministic, perfect information games such as: - Tic-Tac-Toe - Chess - Checkers - Connect Four - Go (with modifications like Monte Carlo Tree Search)</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-how-minimax-works","title":"\ud83d\udd39 How Minimax Works","text":"<p>The algorithm evaluates the entire game tree to find the best possible move. The key idea is: - MAX chooses the move that leads to the highest value (best for MAX). - MIN responds with the move that leads to the lowest value (worst for MAX). - This continues until reaching terminal states (win, loss, or draw).</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-understanding-the-minimax-tree","title":"\ud83d\udd39 Understanding the Minimax Tree","text":"<p>A game tree represents all possible moves and counter-moves. The algorithm propagates utility values from terminal states back to the root.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#example-minimax-game-tree-tic-tac-toe","title":"Example Minimax Game Tree (Tic-Tac-Toe)","text":"<pre><code>graph TD\n    A[\"Initial Game State\"] --&gt; B1[\"Move 1 (MAX)\"]\n    A --&gt; B2[\"Move 2 (MAX)\"]\n\n    B1 --&gt; C1[\"Move 1.1 (MIN)\"]\n    B1 --&gt; C2[\"Move 1.2 (MIN)\"]\n    B2 --&gt; C3[\"Move 2.1 (MIN)\"]\n    B2 --&gt; C4[\"Move 2.2 (MIN)\"]\n\n    %% Terminal Utility Values\n    C1 --&gt; D1[\"Utility: -1 (MIN Wins)\"]\n    C1 --&gt; D2[\"Utility: 0 (Draw)\"]\n    C2 --&gt; D3[\"Utility: +1 (MAX Wins)\"]\n    C3 --&gt; D4[\"Utility: 0 (Draw)\"]\n    C4 --&gt; D5[\"Utility: +1 (MAX Wins)\"]</code></pre> <p>\u2705 What happens? 1. Terminal states (bottom nodes) have utility values assigned:    - +1 (MAX wins)    - -1 (MIN wins)    - 0 (Draw) 2. The values propagate upwards, allowing MAX and MIN to make optimal choices.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-steps-of-the-minimax-algorithm","title":"\ud83d\udd39 Steps of the Minimax Algorithm","text":"<ol> <li>Generate the game tree:</li> <li>Start from the current game state (root node).</li> <li> <p>Expand all possible legal moves for MAX and MIN.</p> </li> <li> <p>Assign utility values to terminal states:</p> </li> <li>If MAX wins, assign +1.</li> <li>If MIN wins, assign -1.</li> <li> <p>If it's a draw, assign 0.</p> </li> <li> <p>Propagate values upwards:</p> </li> <li>At MIN nodes, choose the minimum value from child nodes.</li> <li> <p>At MAX nodes, choose the maximum value from child nodes.</p> </li> <li> <p>Select the optimal move:</p> </li> <li>At the root, MAX picks the move leading to the highest value.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-minimax-algorithm-pseudocode","title":"\ud83d\udd39 Minimax Algorithm Pseudocode","text":"<p>Below is a simple recursive pseudocode for the Minimax Algorithm.</p> <pre><code>def minimax(state, depth, is_maximizing):\n    if is_terminal(state) or depth == 0:\n        return evaluate(state)\n\n    if is_maximizing:\n        best_value = -infinity\n        for move in get_possible_moves(state):\n            new_state = apply_move(state, move)\n            value = minimax(new_state, depth - 1, False)\n            best_value = max(best_value, value)\n        return best_value\n    else:  # Minimizing player\n        best_value = +infinity\n        for move in get_possible_moves(state):\n            new_state = apply_move(state, move)\n            value = minimax(new_state, depth - 1, True)\n            best_value = min(best_value, value)\n        return best_value\n</code></pre>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-time-complexity-of-minimax","title":"\ud83d\udd39 Time Complexity of Minimax","text":"<ul> <li>Branching Factor (b): Number of possible moves per turn.</li> <li>Depth (d): Number of turns the game can last.</li> </ul> <p>The total number of nodes in the tree is O(b^d). - Tic-Tac-Toe: Small enough to evaluate completely. - Chess/Checkers: Too large \u2192 needs Alpha-Beta Pruning for optimization.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-strengths--weaknesses-of-minimax","title":"\ud83d\udd39 Strengths &amp; Weaknesses of Minimax","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Guaranteed optimal play (if full tree is searched). \u2714 Works well in small, perfect-information games. \u2714 Forms the basis for stronger AI algorithms (e.g., Alpha-Beta Pruning, Monte Carlo Tree Search).  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 Computationally expensive (O(b^d)). \u2716 Doesn\u2019t work well in stochastic or hidden-information games (like Poker). \u2716 Needs heuristic evaluation functions for deeper searches.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 Minimax is an optimal decision-making algorithm for turn-based, zero-sum games. \u2714 It evaluates the full game tree and chooses the best possible move. \u2714 Each player alternates between maximizing and minimizing the game\u2019s value. \u2714 Large games require optimizations (e.g., Alpha-Beta Pruning).  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.1_minimax/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Learn Alpha-Beta Pruning (5.3) to optimize Minimax.</li> <li>Implement a working Minimax AI for Tic-Tac-Toe.</li> <li>Explore Monte Carlo Tree Search for complex games like Go.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/","title":"\ud83d\udcd6 5.2.2 Optimal Decisions in Multiplayer Games","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>In the previous section (5.2.1), we explored Minimax as a strategy for two-player, zero-sum games like Chess and Tic-Tac-Toe. However, many games involve more than two players, requiring a more complex decision-making process.</p> <p>This section introduces optimal decision-making strategies for multiplayer games, focusing on general-sum games, where: - More than two players compete or cooperate. - The game is not strictly zero-sum (one player\u2019s gain does not always mean another player\u2019s loss).</p> <p>Multiplayer games introduce new challenges, such as: - Coalitions and alliances (temporary or long-term cooperation between players). - More complex strategy spaces (choosing whether to attack or cooperate).</p> <p>Examples of multiplayer games: - Poker (multiple players competing with hidden information) - Settlers of Catan (economic resource competition with trade negotiations) - Risk (territory control with temporary alliances) - Online multiplayer strategy games (e.g., Starcraft, Civilization)</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-differences-between-two-player-and-multiplayer-games","title":"\ud83d\udd39 Differences Between Two-Player and Multiplayer Games","text":"Feature Two-Player Games (e.g., Chess) Multiplayer Games (e.g., Poker) Number of Players Exactly two Three or more Strategy Type Minimax (Zero-Sum) Generalized Payoff Maximization Win/Loss Condition One player wins, the other loses (zero-sum) Players may win individually, form alliances, or cooperate Decision Complexity Simple evaluation (Max vs. Min) Multiple strategies, mixed incentives Computation Complexity O(b^d) (Exponential growth) Higher complexity due to multiple opponents"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-key-differences","title":"\u2705 Key Differences","text":"<p>\u2714 In two-player games, each player directly opposes the other. \u2714 In multiplayer games, players may compete, cooperate, or bluff. \u2714 Game trees grow much faster, making full search impractical for large games.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-game-theory-and-multiplayer-decision-making","title":"\ud83d\udd39 Game Theory and Multiplayer Decision Making","text":"<p>When a game involves more than two players, Minimax is no longer sufficient. Instead, we use concepts from Game Theory, such as:</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#1-nash-equilibrium-john-nash-1950","title":"1\ufe0f\u20e3 Nash Equilibrium (John Nash, 1950)","text":"<ul> <li>A stable strategy profile where no player can improve their position by changing strategies if others stick to theirs.</li> <li>Example: In Poker, if everyone plays optimally, no single player benefits from unilaterally changing their strategy.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#2-cooperative-vs-non-cooperative-games","title":"2\ufe0f\u20e3 Cooperative vs. Non-Cooperative Games","text":"<ul> <li>Cooperative: Players can form alliances or coalitions.</li> <li>Non-Cooperative: No alliances are allowed, and each player acts selfishly.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#3-mixed-strategies-probability-based-play","title":"3\ufe0f\u20e3 Mixed Strategies (Probability-Based Play)","text":"<ul> <li>Instead of choosing a single deterministic move, players assign probabilities to different strategies.</li> <li>Example: In Rock-Paper-Scissors, playing randomly (33% for each move) prevents predictability.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-game-trees-for-multiplayer-games","title":"\ud83d\udd39 Game Trees for Multiplayer Games","text":"<p>Multiplayer games still use game trees, but instead of alternating between MAX and MIN, we track all players separately.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#example-a-three-player-game-tree","title":"Example: A Three-Player Game Tree","text":"<pre><code>graph TD\n    A[\"Initial State\"] --&gt; B1[\"Player 1 Moves\"]\n    A --&gt; B2[\"Player 2 Moves\"]\n\n    B1 --&gt; C1[\"Player 2 Moves\"]\n    B1 --&gt; C2[\"Player 3 Moves\"]\n\n    C1 --&gt; D1[\"Player 3 Moves\"]\n    C2 --&gt; D2[\"Player 2 Moves\"]\n\n    %% Terminal Utility Values\n    D1 --&gt; E1[\"Final Payoff for P1, P2, P3\"]\n    D2 --&gt; E2[\"Final Payoff for P1, P2, P3\"]</code></pre> <p>\u2705 What happens here? - The game does not alternate between two players. - Each player gets a turn and evaluates possible outcomes. - Instead of a single minimax score, we track payoff values for all players.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-the-extended-minimax-algorithm-for-multiplayer-games","title":"\ud83d\udd39 The Extended Minimax Algorithm for Multiplayer Games","text":"<p>For two-player zero-sum games, Minimax works well. But for multiplayer games, we need to generalize it.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-steps-for-multiplayer-minimax","title":"\ud83d\udccc Steps for Multiplayer Minimax:","text":"<ol> <li>Construct the game tree with all possible moves.</li> <li>Assign a utility function that considers all players (not just MAX and MIN).</li> <li>Each player acts in their own self-interest, maximizing their expected outcome.</li> <li>The game tree propagates multiple values instead of one (vector-valued payoffs).</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-multiplayer-minimax-pseudocode","title":"\ud83d\udd39 Multiplayer Minimax Pseudocode","text":"<p>Below is the extended Minimax algorithm for multiplayer games:</p> <pre><code>def multiplayer_minimax(state, depth, player_index, num_players):\n    if is_terminal(state) or depth == 0:\n        return evaluate(state)  # Return a list of utility values\n\n    best_values = [-float('inf')] * num_players  # Track best outcome for all players\n\n    for move in get_possible_moves(state, player_index):\n        new_state = apply_move(state, move)\n        next_player = (player_index + 1) % num_players  # Rotate to the next player\n        values = multiplayer_minimax(new_state, depth - 1, next_player, num_players)\n\n        if values[player_index] &gt; best_values[player_index]:  # Maximizing for current player\n            best_values = values\n\n    return best_values\n</code></pre> <p>\u2705 How this works: - Instead of just MAX vs. MIN, this version tracks all players. - Each player maximizes their own score, considering what others might do.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-time-complexity-of-multiplayer-minimax","title":"\ud83d\udd39 Time Complexity of Multiplayer Minimax","text":"<ul> <li>Two-player Minimax: O(b^d) </li> <li>Multiplayer Minimax: O(b^(d * p)) (where <code>p = number of players</code>).  </li> </ul> <p>\ud83d\udd34 Multiplayer games grow exponentially larger, making full searches impractical. \u2705 Optimizations (like pruning and Monte Carlo methods) are required.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-when-is-multiplayer-minimax-used","title":"\ud83d\udd39 When is Multiplayer Minimax Used?","text":"Game Multiplayer Minimax Feasibility Why? Tic-Tac-Toe \u274c No Only 2 players Poker \u2705 Yes Bluffing, multiple players Settlers of Catan \u2705 Yes Trading, alliances Risk (Board Game) \u2705 Yes Territory control StarCraft AI \u2705 Yes Complex multiplayer strategy"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-strengths--weaknesses-of-multiplayer-minimax","title":"\ud83d\udd39 Strengths &amp; Weaknesses of Multiplayer Minimax","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Works well in strategy-based multiplayer games. \u2714 Can model coalitions and strategic alliances. \u2714 Uses game theory concepts like Nash Equilibrium.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 Computationally more expensive than standard Minimax. \u2716 Difficult to handle hidden information (e.g., Poker). \u2716 Does not consider human psychology (bluffing, deception).  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 Multiplayer Minimax extends two-player Minimax to multiple agents. \u2714 Players do not strictly alternate; instead, each acts in their own self-interest. \u2714 Utility values are vector-based, tracking multiple payoffs. \u2714 Game complexity increases exponentially, requiring optimizations like Monte Carlo Search.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.2_multiplayer_minimax/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Learn Alpha-Beta Pruning for multiplayer games.  </li> <li>Implement Multiplayer Minimax AI in a game like Poker.  </li> <li>Explore Monte Carlo Tree Search (MCTS) for better decision-making.  </li> </ul> <p>\u2705 Would you like a Python implementation of Multiplayer Minimax? \ud83d\ude80</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/","title":"\ud83d\udcd6 5.2.3 Alpha\u2013Beta Pruning","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>In the previous sections, we explored the Minimax Algorithm for making optimal decisions in two-player zero-sum games. However, Minimax has a major weakness: it evaluates all possible moves, which becomes computationally expensive for large games like Chess or Go.</p> <p>Alpha-Beta Pruning is an optimization technique for Minimax that significantly reduces the number of nodes that need to be evaluated, making Minimax faster without affecting the final decision.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-why-use-alpha-beta-pruning","title":"\u2705 Why Use Alpha-Beta Pruning?","text":"<p>\u2714 Reduces the number of nodes that must be explored. \u2714 Maintains the same optimal decision as Minimax. \u2714 Speeds up decision-making in complex games like Chess. \u2714 Efficiently searches deeper levels in the game tree.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-what-is-alpha-beta-pruning","title":"\ud83d\udd39 What is Alpha-Beta Pruning?","text":"<p>Alpha-Beta Pruning eliminates branches in the game tree that won\u2019t influence the final decision. It uses two values: - Alpha (\u03b1): The best value MAX can guarantee so far. - Beta (\u03b2): The best value MIN can guarantee so far.</p> <p>During the Minimax search: - If MIN finds a move worse than an already evaluated option, it stops searching that branch. - If MAX finds a move better than an already evaluated option, it stops searching that branch. </p> <p>\u2705 This saves time by avoiding unnecessary calculations.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-alpha-beta-pruning-algorithm-steps","title":"\ud83d\udd39 Alpha-Beta Pruning Algorithm Steps","text":"<ol> <li>Set \u03b1 = -\u221e (worst for MAX) and \u03b2 = +\u221e (worst for MIN).</li> <li>Traverse the game tree using Minimax.</li> <li>At each node:</li> <li>If MAX finds a move better than \u03b2, stop evaluating that branch (prune).</li> <li>If MIN finds a move worse than \u03b1, stop evaluating that branch (prune).</li> <li>Continue the search while updating \u03b1 and \u03b2 values dynamically.</li> <li>Return the best possible move for MAX.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-alpha-beta-pruning-pseudocode","title":"\ud83d\udd39 Alpha-Beta Pruning Pseudocode","text":"<p>Here is a recursive implementation of Alpha-Beta Pruning:</p> <pre><code>def alphabeta(state, depth, alpha, beta, is_maximizing):\n    if is_terminal(state) or depth == 0:\n        return evaluate(state)\n\n    if is_maximizing:\n        best_value = -float(\"inf\")\n        for move in get_possible_moves(state):\n            new_state = apply_move(state, move)\n            value = alphabeta(new_state, depth - 1, alpha, beta, False)\n            best_value = max(best_value, value)\n            alpha = max(alpha, best_value)  # Update \u03b1\n\n            if beta &lt;= alpha:  # Beta Cutoff (Prune)\n                break\n        return best_value\n\n    else:  # Minimizing Player (MIN)\n        best_value = float(\"inf\")\n        for move in get_possible_moves(state):\n            new_state = apply_move(state, move)\n            value = alphabeta(new_state, depth - 1, alpha, beta, True)\n            best_value = min(best_value, value)\n            beta = min(beta, best_value)  # Update \u03b2\n\n            if beta &lt;= alpha:  # Alpha Cutoff (Prune)\n                break\n        return best_value\n</code></pre> <p>\u2705 What this does: - Updates \u03b1 (MAX\u2019s best move) and \u03b2 (MIN\u2019s best move) dynamically. - Prunes branches when \u03b2 \u2264 \u03b1 (no need to explore further). - Ensures the same optimal move as Minimax but faster.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-time-complexity-of-alpha-beta-pruning","title":"\ud83d\udd39 Time Complexity of Alpha-Beta Pruning","text":"Algorithm Time Complexity Explored Nodes Minimax O(b^d) Explores all nodes Alpha-Beta Pruning O(b^(d/2)) Explores fewer nodes <p>\u2705 Why is Alpha-Beta Pruning Faster? - Pruning eliminates branches that won\u2019t influence the final decision. - Allows the AI to search deeper in the same amount of time.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-strengths--weaknesses-of-alpha-beta-pruning","title":"\ud83d\udd39 Strengths &amp; Weaknesses of Alpha-Beta Pruning","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Significantly reduces computation time compared to Minimax. \u2714 Allows deeper searches in complex games like Chess. \u2714 Still finds the same optimal move as Minimax.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 Does not work well if moves are unordered (bad ordering reduces pruning). \u2716 Still exponential complexity (O(b^(d/2)), but better than O(b^d)). \u2716 Limited usefulness in non-zero-sum games (e.g., Poker).  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 Alpha-Beta Pruning speeds up Minimax without changing the final decision. \u2714 Pruning occurs when we find a move that makes further search unnecessary. \u2714 The best case occurs when moves are sorted from best to worst. \u2714 Allows AI to play games like Chess and Go more efficiently.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.3_alpha_beta_pruning/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement Alpha-Beta Pruning for Tic-Tac-Toe or Chess AI.  </li> <li>Learn Move Ordering techniques to improve pruning efficiency.  </li> <li>Explore Monte Carlo Tree Search (MCTS) as an alternative to Minimax.  </li> </ul> <p>\u2705 Would you like a Python implementation of Alpha-Beta Pruning for Chess? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/","title":"\ud83d\udcd6 5.2.4 Move Ordering","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.2.4 Move Ordering, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-key-concepts-in-524-move-ordering","title":"\ud83d\udd39 Key Concepts in 5.2.4 Move Ordering","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.2.4 move ordering and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.2.4 Move Ordering principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-algorithm-pseudocode-for-524-move-ordering","title":"\ud83d\udd39 Algorithm Pseudocode for 5.2.4 Move Ordering","text":"<p><pre><code>def 5_2_4_move_ordering(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_2_4_move_ordering(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-strengths--weaknesses-of-524-move-ordering","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.2.4 Move Ordering","text":""},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.2.4 Move Ordering helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2.4_move_ordering/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.2.4 Move Ordering in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.2.4 Move Ordering? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.2/","title":"\ud83d\udcd6 5.2 Optimal Decisions in Games","text":""},{"location":"courses/intro-to-ai/chapter5/5.2/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>In this section, we explore how AI makes optimal decisions in two-player zero-sum games using game trees and adversarial search. The main focus is on how to evaluate moves strategically by simulating possible game states.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2/#-what-is-an-optimal-move","title":"\ud83d\udd39 What is an Optimal Move?","text":"<p>An optimal move in a game is one that guarantees the best possible outcome assuming the opponent also plays optimally. This means: - AI does not just look at the immediate best move but considers all possible counter-moves from the opponent. - AI must evaluate game trees to choose the move that leads to the best long-term result.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2/#example-tic-tac-toe","title":"Example: Tic-Tac-Toe","text":"<ul> <li>Suppose you are X, and it is your turn.</li> <li>If you have two X's in a row, an optimal move is placing your third X to win immediately.</li> <li>If no immediate win is available, the AI looks ahead to prevent the opponent from winning.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/5.2/#-how-ai-makes-decisions-in-games","title":"\ud83d\udd39 How AI Makes Decisions in Games","text":"<p>AI uses game trees to simulate possible future moves.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2/#what-is-a-game-tree-","title":"What is a Game Tree? \ud83c\udf33","text":"<p>A game tree represents all possible moves and responses in a game.</p>"},{"location":"courses/intro-to-ai/chapter5/5.2/#example-a-simple-tic-tac-toe-tree","title":"Example: A simple Tic-Tac-Toe tree","text":"<pre><code>graph TD\n    A[\"Current State\"] --&gt; B1[\"X places in top-left\"]\n    A --&gt; B2[\"X places in center\"]\n    A --&gt; B3[\"X places in bottom-right\"]\n\n    B1 --&gt; C1[\"O places in center\"]\n    B1 --&gt; C2[\"O places in bottom-right\"]\n    B2 --&gt; C3[\"O places in top-left\"]\n    B2 --&gt; C4[\"O places in bottom-right\"]\n    B3 --&gt; C5[\"O places in center\"]\n    B3 --&gt; C6[\"O places in top-left\"]\n\n    %% Terminal Outcomes\n    C1 --&gt; D1[\"Win for X\"]\n    C2 --&gt; D2[\"Draw\"]\n    C3 --&gt; D3[\"Win for O\"]</code></pre>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/","title":"\ud83d\udcd6 5.3.1 Cutting Off Search in Depth-Limited Minimax","text":""},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.3.1 Cutting Off Search in Depth-Limited Minimax, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-key-concepts-in-531-cutting-off-search-in-depth-limited-minimax","title":"\ud83d\udd39 Key Concepts in 5.3.1 Cutting Off Search in Depth-Limited Minimax","text":""},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.3.1 cutting off search in depth-limited minimax and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.3.1 Cutting Off Search in Depth-Limited Minimax principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-algorithm-pseudocode-for-531-cutting-off-search-in-depth-limited-minimax","title":"\ud83d\udd39 Algorithm Pseudocode for 5.3.1 Cutting Off Search in Depth-Limited Minimax","text":"<p><pre><code>def 5_3_1_cutting_off_search_in_depth_limited_minimax(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_3_1_cutting_off_search_in_depth_limited_minimax(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-strengths--weaknesses-of-531-cutting-off-search-in-depth-limited-minimax","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.3.1 Cutting Off Search in Depth-Limited Minimax","text":""},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.3.1 Cutting Off Search in Depth-Limited Minimax helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.3.1_cutting_off_search_in_depth_limited_minimax/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.3.1 Cutting Off Search in Depth-Limited Minimax in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.3.1 Cutting Off Search in Depth-Limited Minimax? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/","title":"\ud83d\udcd6 5.3.2 Effect of Depth Limitations","text":""},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.3.2 Effect of Depth Limitations, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-key-concepts-in-532-effect-of-depth-limitations","title":"\ud83d\udd39 Key Concepts in 5.3.2 Effect of Depth Limitations","text":""},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.3.2 effect of depth limitations and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.3.2 Effect of Depth Limitations principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-algorithm-pseudocode-for-532-effect-of-depth-limitations","title":"\ud83d\udd39 Algorithm Pseudocode for 5.3.2 Effect of Depth Limitations","text":"<p><pre><code>def 5_3_2_effect_of_depth_limitations(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_3_2_effect_of_depth_limitations(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-strengths--weaknesses-of-532-effect-of-depth-limitations","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.3.2 Effect of Depth Limitations","text":""},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.3.2 Effect of Depth Limitations helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.3.2_effect_of_depth_limitations/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.3.2 Effect of Depth Limitations in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.3.2 Effect of Depth Limitations? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/","title":"\ud83d\udcd6 5.4.1 Forward Pruning Strategies","text":""},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.4.1 Forward Pruning Strategies, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-key-concepts-in-541-forward-pruning-strategies","title":"\ud83d\udd39 Key Concepts in 5.4.1 Forward Pruning Strategies","text":""},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.4.1 forward pruning strategies and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.4.1 Forward Pruning Strategies principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-algorithm-pseudocode-for-541-forward-pruning-strategies","title":"\ud83d\udd39 Algorithm Pseudocode for 5.4.1 Forward Pruning Strategies","text":"<p><pre><code>def 5_4_1_forward_pruning_strategies(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_4_1_forward_pruning_strategies(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-strengths--weaknesses-of-541-forward-pruning-strategies","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.4.1 Forward Pruning Strategies","text":""},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.4.1 Forward Pruning Strategies helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.4.1_forward_pruning_strategies/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.4.1 Forward Pruning Strategies in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.4.1 Forward Pruning Strategies? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/","title":"\ud83d\udcd6 5.4.2 Risks of Aggressive Forward Pruning","text":""},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.4.2 Risks of Aggressive Forward Pruning, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-key-concepts-in-542-risks-of-aggressive-forward-pruning","title":"\ud83d\udd39 Key Concepts in 5.4.2 Risks of Aggressive Forward Pruning","text":""},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.4.2 risks of aggressive forward pruning and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.4.2 Risks of Aggressive Forward Pruning principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-algorithm-pseudocode-for-542-risks-of-aggressive-forward-pruning","title":"\ud83d\udd39 Algorithm Pseudocode for 5.4.2 Risks of Aggressive Forward Pruning","text":"<p><pre><code>def 5_4_2_risks_of_aggressive_forward_pruning(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_4_2_risks_of_aggressive_forward_pruning(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-strengths--weaknesses-of-542-risks-of-aggressive-forward-pruning","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.4.2 Risks of Aggressive Forward Pruning","text":""},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.4.2 Risks of Aggressive Forward Pruning helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.4.2_risks_of_aggressive_forward_pruning/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.4.2 Risks of Aggressive Forward Pruning in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.4.2 Risks of Aggressive Forward Pruning? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/","title":"\ud83d\udcd6 5.5.1 Extensions for Deeper Analysis","text":""},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.5.1 Extensions for Deeper Analysis, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-key-concepts-in-551-extensions-for-deeper-analysis","title":"\ud83d\udd39 Key Concepts in 5.5.1 Extensions for Deeper Analysis","text":""},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.5.1 extensions for deeper analysis and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.5.1 Extensions for Deeper Analysis principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-algorithm-pseudocode-for-551-extensions-for-deeper-analysis","title":"\ud83d\udd39 Algorithm Pseudocode for 5.5.1 Extensions for Deeper Analysis","text":"<p><pre><code>def 5_5_1_extensions_for_deeper_analysis(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_5_1_extensions_for_deeper_analysis(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-strengths--weaknesses-of-551-extensions-for-deeper-analysis","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.5.1 Extensions for Deeper Analysis","text":""},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.5.1 Extensions for Deeper Analysis helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.5.1_extensions_for_deeper_analysis/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.5.1 Extensions for Deeper Analysis in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.5.1 Extensions for Deeper Analysis? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/","title":"\ud83d\udcd6 5.5.2 Improving Evaluation Functions","text":""},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.5.2 Improving Evaluation Functions, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-key-concepts-in-552-improving-evaluation-functions","title":"\ud83d\udd39 Key Concepts in 5.5.2 Improving Evaluation Functions","text":""},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.5.2 improving evaluation functions and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.5.2 Improving Evaluation Functions principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-algorithm-pseudocode-for-552-improving-evaluation-functions","title":"\ud83d\udd39 Algorithm Pseudocode for 5.5.2 Improving Evaluation Functions","text":"<p><pre><code>def 5_5_2_improving_evaluation_functions(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_5_2_improving_evaluation_functions(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-strengths--weaknesses-of-552-improving-evaluation-functions","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.5.2 Improving Evaluation Functions","text":""},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.5.2 Improving Evaluation Functions helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.5.2_improving_evaluation_functions/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.5.2 Improving Evaluation Functions in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.5.2 Improving Evaluation Functions? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/","title":"\ud83d\udcd6 5.6.1 Stochastic Game Trees","text":""},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.6.1 Stochastic Game Trees, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-key-concepts-in-561-stochastic-game-trees","title":"\ud83d\udd39 Key Concepts in 5.6.1 Stochastic Game Trees","text":""},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.6.1 stochastic game trees and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.6.1 Stochastic Game Trees principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-algorithm-pseudocode-for-561-stochastic-game-trees","title":"\ud83d\udd39 Algorithm Pseudocode for 5.6.1 Stochastic Game Trees","text":"<p><pre><code>def 5_6_1_stochastic_game_trees(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_6_1_stochastic_game_trees(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-strengths--weaknesses-of-561-stochastic-game-trees","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.6.1 Stochastic Game Trees","text":""},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.6.1 Stochastic Game Trees helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.6.1_stochastic_game_trees/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.6.1 Stochastic Game Trees in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.6.1 Stochastic Game Trees? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/","title":"\ud83d\udcd6 5.6.2 Expectimax Algorithm","text":""},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.6.2 Expectimax Algorithm, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-key-concepts-in-562-expectimax-algorithm","title":"\ud83d\udd39 Key Concepts in 5.6.2 Expectimax Algorithm","text":""},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.6.2 expectimax algorithm and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.6.2 Expectimax Algorithm principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-algorithm-pseudocode-for-562-expectimax-algorithm","title":"\ud83d\udd39 Algorithm Pseudocode for 5.6.2 Expectimax Algorithm","text":"<p><pre><code>def 5_6_2_expectimax_algorithm(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_6_2_expectimax_algorithm(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-strengths--weaknesses-of-562-expectimax-algorithm","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.6.2 Expectimax Algorithm","text":""},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.6.2 Expectimax Algorithm helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.6.2_expectimax_algorithm/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.6.2 Expectimax Algorithm in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.6.2 Expectimax Algorithm? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/","title":"\ud83d\udcd6 5.7.1 Games with Hidden Information","text":""},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.7.1 Games with Hidden Information, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-key-concepts-in-571-games-with-hidden-information","title":"\ud83d\udd39 Key Concepts in 5.7.1 Games with Hidden Information","text":""},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.7.1 games with hidden information and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.7.1 Games with Hidden Information principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-algorithm-pseudocode-for-571-games-with-hidden-information","title":"\ud83d\udd39 Algorithm Pseudocode for 5.7.1 Games with Hidden Information","text":"<p><pre><code>def 5_7_1_games_with_hidden_information(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_7_1_games_with_hidden_information(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-strengths--weaknesses-of-571-games-with-hidden-information","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.7.1 Games with Hidden Information","text":""},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.7.1 Games with Hidden Information helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.7.1_games_with_hidden_information/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.7.1 Games with Hidden Information in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.7.1 Games with Hidden Information? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/","title":"\ud83d\udcd6 5.7.2 Search Methods for Partially Observable Games","text":""},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.7.2 Search Methods for Partially Observable Games, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-key-concepts-in-572-search-methods-for-partially-observable-games","title":"\ud83d\udd39 Key Concepts in 5.7.2 Search Methods for Partially Observable Games","text":""},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.7.2 search methods for partially observable games and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.7.2 Search Methods for Partially Observable Games principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-algorithm-pseudocode-for-572-search-methods-for-partially-observable-games","title":"\ud83d\udd39 Algorithm Pseudocode for 5.7.2 Search Methods for Partially Observable Games","text":"<p><pre><code>def 5_7_2_search_methods_for_partially_observable_games(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_7_2_search_methods_for_partially_observable_games(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-strengths--weaknesses-of-572-search-methods-for-partially-observable-games","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.7.2 Search Methods for Partially Observable Games","text":""},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.7.2 Search Methods for Partially Observable Games helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.7.2_search_methods_for_partially_observable_games/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.7.2 Search Methods for Partially Observable Games in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.7.2 Search Methods for Partially Observable Games? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/","title":"\ud83d\udcd6 5.8.1 Historical AI Game Programs","text":""},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.8.1 Historical AI Game Programs, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-key-concepts-in-581-historical-ai-game-programs","title":"\ud83d\udd39 Key Concepts in 5.8.1 Historical AI Game Programs","text":""},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.8.1 historical ai game programs and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.8.1 Historical AI Game Programs principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-algorithm-pseudocode-for-581-historical-ai-game-programs","title":"\ud83d\udd39 Algorithm Pseudocode for 5.8.1 Historical AI Game Programs","text":"<p><pre><code>def 5_8_1_historical_ai_game_programs(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_8_1_historical_ai_game_programs(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-strengths--weaknesses-of-581-historical-ai-game-programs","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.8.1 Historical AI Game Programs","text":""},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.8.1 Historical AI Game Programs helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.8.1_historical_ai_game_programs/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.8.1 Historical AI Game Programs in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.8.1 Historical AI Game Programs? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/","title":"\ud83d\udcd6 5.8.2 Modern Advancements in Game AI","text":""},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-introduction","title":"\ud83d\udccc Introduction","text":"<p>This section discusses 5.8.2 Modern Advancements in Game AI, which plays a crucial role in adversarial search and AI decision-making. </p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-why-is-this-important","title":"\u2705 Why is this important?","text":"<p>\u2714 Helps AI make smarter and more efficient decisions. \u2714 Reduces computation complexity in large search spaces. \u2714 Used in real-world AI applications, including Chess engines and video game AI.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-key-concepts-in-582-modern-advancements-in-game-ai","title":"\ud83d\udd39 Key Concepts in 5.8.2 Modern Advancements in Game AI","text":""},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#understanding-the-concept","title":"Understanding the Concept","text":"<p>This section explores 5.8.2 modern advancements in game ai and its impact on AI game decision-making.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#example-game-tree-mermaid-diagram","title":"Example Game Tree (Mermaid Diagram)","text":"<p><pre><code>graph TD\n    A[\"Root State\"] --&gt; B1[\"Example Node 1\"]\n    A --&gt; B2[\"Example Node 2\"]\n    B1 --&gt; C1[\"Example Leaf 1\"]\n    B1 --&gt; C2[\"Example Leaf 2\"]\n    B2 --&gt; C3[\"Example Leaf 3\"]\n    B2 --&gt; C4[\"Example Leaf 4\"]</code></pre> \u2705 What happens here? - The AI analyzes possible moves. - Decision paths are evaluated using specific heuristics.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-algorithm-steps","title":"\ud83d\udd39 Algorithm Steps","text":"<ol> <li>Step 1: Define the search space.</li> <li>Step 2: Apply heuristics or probability-based decision-making.</li> <li>Step 3: Optimize search paths using 5.8.2 Modern Advancements in Game AI principles.</li> <li>Step 4: Compute final decision-making output.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-algorithm-pseudocode-for-582-modern-advancements-in-game-ai","title":"\ud83d\udd39 Algorithm Pseudocode for 5.8.2 Modern Advancements in Game AI","text":"<p><pre><code>def 5_8_2_modern_advancements_in_game_ai(state, parameters):\n    if is_terminal(state):\n        return evaluate(state)\n\n    for move in get_possible_moves(state):\n        new_state = apply_move(state, move)\n        value = 5_8_2_modern_advancements_in_game_ai(new_state, updated_parameters)\n        best_value = optimize_based_on_section(value)\n\n    return best_value\n</code></pre> \u2705 How this works: - Evaluates possible outcomes. - Optimizes decision paths dynamically. - Provides faster and more effective AI decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-strengths--weaknesses-of-582-modern-advancements-in-game-ai","title":"\ud83d\udd39 Strengths &amp; Weaknesses of 5.8.2 Modern Advancements in Game AI","text":""},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-advantages","title":"\u2705 Advantages","text":"<p>\u2714 Reduces computation cost in AI game engines. \u2714 Enhances decision-making speed. \u2714 More optimal performance in complex AI systems.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-disadvantages","title":"\u274c Disadvantages","text":"<p>\u2716 May eliminate potentially good moves if not applied properly. \u2716 Requires fine-tuning based on the specific game. \u2716 Can be ineffective in highly unpredictable games.</p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-key-takeaways","title":"\ud83d\udd39 Key Takeaways","text":"<p>\u2714 5.8.2 Modern Advancements in Game AI helps optimize AI decision-making in adversarial games. \u2714 Reduces unnecessary computations, improving efficiency. \u2714 Used in state-of-the-art AI game engines.  </p>"},{"location":"courses/intro-to-ai/chapter5/5.8.2_modern_advancements_in_game_ai/#-next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Implement 5.8.2 Modern Advancements in Game AI in a real AI-based game.  </li> <li>Learn how modern game engines apply these principles.  </li> <li>Explore advanced AI strategies, such as Monte Carlo Tree Search (MCTS).  </li> </ul> <p>\u2705 Would you like a Python implementation of 5.8.2 Modern Advancements in Game AI? \ud83d\ude80  </p>"},{"location":"courses/intro-to-ai/chapter5/game-theory/","title":"5.1 Game Theory","text":""},{"location":"courses/intro-to-ai/chapter5/game-theory/#overview","title":"Overview","text":"<p>Game theory provides a mathematical framework for modeling multi-agent environments where the outcomes for each agent depend on the actions of others. It is widely applied in adversarial search to analyze competitive scenarios, such as games.</p>"},{"location":"courses/intro-to-ai/chapter5/game-theory/#vocabulary-and-definitions","title":"Vocabulary and Definitions","text":"Term Definition Game A scenario involving multiple players, each with a set of strategies and payoffs. Player An agent that participates in the game, aiming to maximize its payoff. Strategy A plan of action or decision-making rule for a player in the game. Pure Strategy A deterministic approach where a player always selects the same move in a given situation. Mixed Strategy A probabilistic approach where a player assigns probabilities to different moves. Utility Function A numerical value representing the desirability of a game state for a player. Payoff Matrix A table showing the payoffs for each combination of strategies by the players. Zero-Sum Game A game where one player\u2019s gain is the other player\u2019s loss. Nash Equilibrium A stable state where no player benefits from unilaterally changing their strategy. Minimax Principle A decision rule where a player minimizes the maximum possible loss. Adversarial Search A search method where multiple agents compete, aiming to maximize their utility while minimizing the opponent's. Economy The concept of efficiently using resources, often applied in AI to optimize computation and decision-making. Pruning A technique in search algorithms (e.g., Alpha-Beta Pruning) that eliminates branches in the game tree that do not need to be explored. Evaluation Function A heuristic function used in games to approximate the value of a game state when it is impractical to search all the way to terminal nodes. Imperfect Information A type of game where players do not have full knowledge of the game state, such as in Poker where opponents' hands are hidden."},{"location":"courses/intro-to-ai/chapter5/game-theory/#key-concepts","title":"Key Concepts","text":""},{"location":"courses/intro-to-ai/chapter5/game-theory/#1-zero-sum-games","title":"1. Zero-Sum Games","text":"<ul> <li>In zero-sum games, the total payoff for all players is constant. One player\u2019s gain is exactly the other player\u2019s loss.</li> <li>Example: Chess, where one player wins, and the other loses.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/game-theory/#2-strategies","title":"2. Strategies","text":"<ul> <li>Pure Strategy:</li> <li>A deterministic approach where a player always selects the same move in a given situation.</li> <li>Mixed Strategy:</li> <li>A probabilistic approach where a player assigns probabilities to different moves.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/game-theory/#3-nash-equilibrium","title":"3. Nash Equilibrium","text":"<ul> <li>A situation where no player can improve their outcome by unilaterally changing their strategy.</li> <li>At equilibrium, all players are playing optimally given the strategies of others.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/game-theory/#4-minimax-principle","title":"4. Minimax Principle","text":"<ul> <li>A decision rule used in two-player, zero-sum games.</li> <li>Each player minimizes the maximum possible loss:</li> <li>Maximizing Player: Tries to maximize their utility.</li> <li>Minimizing Player: Tries to minimize the maximizing player\u2019s utility.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/game-theory/#payoff-matrix-example","title":"Payoff Matrix Example","text":"<p>A payoff matrix illustrates the payoffs for two players based on their chosen strategies.</p> Player 2 Strategy A Strategy B Player 1: A (3, -3) (-1, 1) Player 1: B (0, 0) (2, -2) <ul> <li>Rows represent Player 1\u2019s strategies.</li> <li>Columns represent Player 2\u2019s strategies.</li> <li>Payoffs are listed as <code>(Player 1 payoff, Player 2 payoff)</code>.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/game-theory/#applications-of-game-theory","title":"Applications of Game Theory","text":"<ul> <li>Adversarial Search:</li> <li>Used in games like chess or Go, where agents compete.</li> <li>Economics:</li> <li>Modeling markets and competitive business strategies.</li> <li>Negotiation and Conflict Resolution:</li> <li>Finding stable strategies in multi-party agreements.</li> <li>Artificial Intelligence:</li> <li>Building rational agents that make strategic decisions.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/game-theory/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Game theory provides tools for modeling competitive and strategic interactions.</li> <li>Zero-sum games highlight direct competition where one player\u2019s gain equals the other\u2019s loss.</li> <li>Concepts like the Minimax Principle and Nash Equilibrium are essential for understanding multi-agent interactions.</li> <li>Payoff matrices provide a simple way to analyze the outcomes of strategies.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/","title":"Notes","text":""},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#overview","title":"Overview","text":"<p>Figure 5.1 from Artificial Intelligence: A Modern Approach represents a game tree for a simplified version of Tic-Tac-Toe (Noughts and Crosses). The diagram demonstrates how: 1. MAX (X) makes the first move, aiming to maximize its advantage. 2. MIN (O) responds, attempting to minimize MAX's possible gains. 3. The game continues until a terminal state is reached, where one player wins, loses, or the game ends in a draw. 4. The utility value at each leaf node represents the outcome from MAX\u2019s perspective:    - +1 \u2192 MAX wins.    - 0 \u2192 Draw.    - -1 \u2192 MIN wins.</p>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#key-elements-in-the-figure","title":"Key Elements in the Figure","text":""},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#1-game-tree-structure","title":"1. Game Tree Structure","text":"<ul> <li>The root node represents the initial state (an empty Tic-Tac-Toe board).</li> <li>Each level alternates between MAX (X) and MIN (O), representing sequential moves.</li> <li>The depth of the tree increases as players make more moves.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#2-alternating-players","title":"2. Alternating Players","text":"<ul> <li>MAX (Offense): Tries to maximize the utility value.</li> <li>MIN (Defense): Tries to minimize MAX's best possible score.</li> <li>Players alternate turns until the game reaches a terminal state.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#3-terminal-states","title":"3. Terminal States","text":"<ul> <li>A terminal state is reached when:</li> <li>One player gets three marks in a row (win).</li> <li>The board is completely filled (draw).</li> <li>Each terminal state is assigned a utility value:</li> <li>+1 \u2192 MAX wins.</li> <li>0 \u2192 Draw.</li> <li>-1 \u2192 MIN wins.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#4-utility-values-at-leaf-nodes","title":"4. Utility Values at Leaf Nodes","text":"<ul> <li>Leaf nodes of the game tree represent final outcomes.</li> <li>The Minimax Algorithm assigns these utility values and propagates them back up the tree to decide the optimal move.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#related-questions-and-answers","title":"Related Questions and Answers","text":""},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#1-is-max-short-for-maximum-and-min-short-for-minimum","title":"1. Is MAX short for Maximum and MIN short for Minimum?","text":"<p>\u2705 Yes. - MAX tries to maximize the utility function (best move for itself). - MIN tries to minimize MAX\u2019s best possible utility (worst-case move for MAX). - This naming convention is used in game theory and adversarial search.</p>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#2-what-are-other-games-like-this","title":"2. What are other games like this?","text":"<p>Games that share the turn-based, zero-sum, perfect information characteristics include: - Chess \u265f\ufe0f - Checkers (Draughts) \ud83c\udfc1 - Go \u26ab\u26aa - Othello (Reversi) \ud83d\udd35\u26ab - Connect Four \u2b55\u274c - Hex \ud83d\udd3a - Shogi (Japanese Chess) \u265c - Nim (Mathematical Strategy Game) \ud83c\udfd7\ufe0f</p> <p>These games can be solved using Minimax and Alpha-Beta Pruning.</p>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#3-does-the-player-that-makes-the-first-move-always-act-as-max","title":"3. Does the player that makes the first move always act as MAX?","text":"<p>\u2705 Yes, in Minimax terminology, MAX always moves first. - MAX plays first, aiming to maximize its utility. - MIN responds, trying to minimize MAX\u2019s best possible outcome. - The roles alternate, but their objectives remain the same.</p>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#4-is-max-offense-and-min-defense","title":"4. Is MAX offense and MIN defense?","text":"<p>\u2705 Yes, generally. - MAX plays offensively, seeking the best move to maximize its advantage. - MIN plays defensively, blocking MAX's moves and forcing the worst-case outcome for MAX. - However, in some games (like Chess), MIN may also act offensively when it sees a chance to win.</p>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#5-dont-their-roles-switch-after-each-move","title":"5. Don\u2019t their roles switch after each move?","text":"<p>\u274c No, their roles do NOT switch. - MAX is always trying to maximize the best possible utility. - MIN is always trying to minimize MAX's best possible outcome. - Even though MIN actively makes moves, it does not become MAX because the game tree is always evaluated from MAX\u2019s perspective.</p>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#6-is-the-first-move-always-offensive-and-the-second-move-always-defensive","title":"6. Is the first move always offensive, and the second move always defensive?","text":"<p>\u2705 Typically, yes. - The first move (MAX) is often an aggressive or strategic placement. - The second move (MIN) is often a defensive counter-move, blocking MAX\u2019s best options. - However, in deeper game states, both players can play offensively or defensively, depending on their strategy.</p>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#conclusion","title":"Conclusion","text":"<p>Figure 5.1 illustrates: - The structure of adversarial search. - How utility values propagate in a game tree. - The foundation for Minimax and Alpha-Beta Pruning.</p> <p>Understanding this diagram helps in building AI for turn-based strategy games, optimizing search algorithms, and designing rational agents in competitive environments.</p>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#tic-tac-toe-game-tree-partial","title":"Tic-Tac-Toe Game Tree (Partial)","text":"<pre><code>graph TD;\n    A[\"Initial State (Empty Board)\"] --&gt; B1[\"X in Top-Left\"]\n    A --&gt; B2[\"X in Top-Middle\"]\n    A --&gt; B3[\"X in Top-Right\"]\n\n    %% MIN Player (O) Moves\n    B1 --&gt; C1[\"O in Center\"]\n    B1 --&gt; C2[\"O in Bottom-Left\"]\n    B2 --&gt; C3[\"O in Center\"]\n    B2 --&gt; C4[\"O in Bottom-Right\"]\n\n    %% Terminal States with Utility Values\n    C1 --&gt; D1[\"Terminal: X Wins (+1)\"]\n    C1 --&gt; D2[\"Terminal: Draw (0)\"]\n    C2 --&gt; D3[\"Terminal: O Wins (-1)\"]\n    C3 --&gt; D4[\"Terminal: Draw (0)\"]\n    C4 --&gt; D5[\"Terminal: X Wins (+1)\"]</code></pre> <p>\u2705 What this shows:</p> <ul> <li>MAX (X) plays first and places X in various positions.</li> <li>MIN (O) responds defensively or aggressively.</li> <li>The utility values at the leaf nodes show who wins.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#2-minimax-game-tree-example","title":"2\ufe0f\u20e3 Minimax Game Tree Example","text":"<p>\ud83d\udca1 Minimax Algorithm works by propagating values up the tree, choosing the best move for MAX and the worst move for MIN.</p> <p><pre><code>graph TD\n    A[\"Initial State\"] --&gt; B1[\"Move 1 (MAX)\"]\n    A --&gt; B2[\"Move 2 (MAX)\"]\n\n    %% MIN's Turn\n    B1 --&gt; C1[\"Move 1.1 (MIN)\"]\n    B1 --&gt; C2[\"Move 1.2 (MIN)\"]\n    B2 --&gt; C3[\"Move 2.1 (MIN)\"]\n    B2 --&gt; C4[\"Move 2.2 (MIN)\"]\n\n    %% Terminal Utility Values\n    C1 --&gt; D1[\"Utility: -1\"]\n    C1 --&gt; D2[\"Utility: 0\"]\n    C2 --&gt; D3[\"Utility: +1\"]\n    C3 --&gt; D4[\"Utility: 0\"]\n    C4 --&gt; D5[\"Utility: +1\"]</code></pre> \u2705 What this shows:</p> <ul> <li>MAX\u2019s turn (choosing best value).</li> <li>MIN\u2019s turn (choosing worst case for MAX).</li> <li>Propagating utility values back up the tree.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#3-minimax-with-utility-propagation","title":"3\ufe0f\u20e3 Minimax with Utility Propagation","text":"<p>\ud83d\udd04 How Minimax Works:</p> <ul> <li>MAX always picks the highest utility from MIN\u2019s moves.</li> <li>MIN always picks the lowest utility to minimize MAX\u2019s advantage.</li> </ul> <pre><code>graph TD\n    A[\"Initial State\"] --&gt; B1[\"Move 1 (MAX)\"]\n    A --&gt; B2[\"Move 2 (MAX)\"]\n\n    %% MIN's Turn\n    B1 --&gt; C1[\"Move 1.1 (MIN)\"]\n    B1 --&gt; C2[\"Move 1.2 (MIN)\"]\n    B2 --&gt; C3[\"Move 2.1 (MIN)\"]\n    B2 --&gt; C4[\"Move 2.2 (MIN)\"]\n\n    %% Terminal Utility Values\n    C1 --&gt; D1[\"Utility: -1\"]\n    C1 --&gt; D2[\"Utility: 0\"]\n    C2 --&gt; D3[\"Utility: +1\"]\n    C3 --&gt; D4[\"Utility: 0\"]\n    C4 --&gt; D5[\"Utility: +1\"]\n\n    %% Propagating Values Back Up\n    C1 -- Min chooses min(-1,0) = -1 --&gt; B1\n    C2 -- Min chooses min(+1) = +1 --&gt; B1\n    C3 -- Min chooses min(0) = 0 --&gt; B2\n    C4 -- Min chooses min(+1) = +1 --&gt; B2\n\n    B1 -- Max chooses max(-1,+1) = +1 --&gt; A\n    B2 -- Max chooses max(0,+1) = +1 --&gt; A</code></pre> <p>\u2705 What this shows:</p> <ul> <li>MIN always chooses the lowest utility available.</li> <li>MAX always chooses the highest utility available.</li> <li>This is how Minimax makes optimal decisions.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#4-alpha-beta-pruning-efficiency-optimization-for-minimax","title":"4\ufe0f\u20e3 Alpha-Beta Pruning (Efficiency Optimization for Minimax)","text":"<p>\ud83d\ude80 Alpha-Beta Pruning skips unnecessary branches when it knows certain moves won\u2019t affect the outcome. <pre><code>graph TD\n    A[\"Initial State\"] --&gt; B1[\"Move 1 (MAX)\"]\n    A --&gt; B2[\"Move 2 (MAX)\"]\n\n    %% MIN's Turn\n    B1 --&gt; C1[\"Move 1.1 (MIN)\"]\n    B1 --&gt; C2[\"Move 1.2 (MIN)\"]\n    B2 --&gt; C3[\"Move 2.1 (MIN)\"]\n    B2 --&gt; C4[\"Move 2.2 (MIN)\"]\n\n    %% Terminal Utility Values\n    C1 --&gt; D1[\"Utility: -1\"]\n    C1 --&gt; D2[\"Utility: 0\"]\n    C2 --&gt; D3[\"Utility: +1\"]\n    C3 --&gt; D4[\"Utility: 0\"]\n    C4 --&gt; D5[\"Utility: +1\"]\n\n    %% Pruned Branch\n    C3 -.-&gt;|Pruned by Alpha-Beta| X1[\"(Ignored)\"]</code></pre></p> <p>\u2705 What this shows:</p> <ul> <li>If one branch already proves to be worse, we don\u2019t need to explore it.</li> <li>Saves computation time and speeds up decision-making.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#5-chess-example-with-minimax","title":"5\ufe0f\u20e3 Chess Example with Minimax","text":"<p>\u265f\ufe0f Minimax also applies to Chess. Here\u2019s an example game tree with Chess-like moves:</p> <pre><code>graph TD\n    A[\"Current Chess Position\"] --&gt; B1[\"Move Knight (MAX)\"]\n    A --&gt; B2[\"Move Bishop (MAX)\"]\n\n    %% MIN's Turn\n    B1 --&gt; C1[\"MIN Blocks\"]\n    B1 --&gt; C2[\"MIN Counterattacks\"]\n    B2 --&gt; C3[\"MIN Defends\"]\n    B2 --&gt; C4[\"MIN Trades Pieces\"]\n\n    %% Terminal Utility Values\n    C1 --&gt; D1[\"-2 (Bad for MAX)\"]\n    C2 --&gt; D2[\"+3 (Good for MAX)\"]\n    C3 --&gt; D3[\"0 (Neutral)\"]\n    C4 --&gt; D4[\"+1 (Slightly Good)\"]</code></pre> <p>\u2705 What this shows:</p> <ul> <li>Chess moves can be analyzed using Minimax.</li> <li>The best move is chosen based on the evaluated utility.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/minimax-deep-dive/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Minimax makes decisions based on best &amp; worst possible moves.</li> <li>Alpha-Beta Pruning speeds up decision-making by cutting out unnecessary calculations.</li> <li>This applies to games like Chess, Checkers, Tic-Tac-Toe, and Go.</li> <li>Game Trees show all possible future moves &amp; consequences.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/overview/","title":"5.0 Adversarial Search and Games","text":""},{"location":"courses/intro-to-ai/chapter5/overview/#overview","title":"Overview","text":"<ul> <li>Adversarial search deals with multi-agent environments, where agents compete with one another.</li> <li>Games are a common example of adversarial environments and serve as a testbed for AI techniques.</li> <li>The goal of adversarial search is to maximize an agent\u2019s utility while minimizing the utility of its opponent.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/overview/#-key-concepts","title":"\ud83e\udde0 Key Concepts","text":"<ol> <li>Game Trees:</li> <li>Represent all possible moves and counter-moves in a game.</li> <li> <p>Used to plan ahead and evaluate possible outcomes.</p> </li> <li> <p>Minimax Algorithm:</p> </li> <li>A decision-making strategy assuming both players play optimally.</li> <li>MAX tries to maximize the outcome.</li> <li> <p>MIN tries to minimize MAX\u2019s advantage.</p> </li> <li> <p>Alpha-Beta Pruning:</p> </li> <li>An optimization of Minimax that eliminates unnecessary calculations.</li> <li> <p>Reduces the number of nodes evaluated, making the search faster.</p> </li> <li> <p>Evaluation Functions:</p> </li> <li>Used when a game tree is too large to search exhaustively.</li> <li> <p>Assigns heuristic values to intermediate game states.</p> </li> <li> <p>Stochastic &amp; Imperfect Information Games:</p> </li> <li>Stochastic Games: Incorporate randomness (e.g., dice rolls in Backgammon).</li> <li>Imperfect Information Games: Players lack full visibility (e.g., Poker).</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/overview/#2-game-trees","title":"2. Game Trees","text":"<ul> <li>Represent the possible moves and states in a game.</li> <li>Root node represents the current state.</li> <li>Children nodes represent possible actions from the current state.</li> <li>Maximizing Agent: The agent trying to maximize its utility.</li> <li>Minimizing Agent: The opponent trying to minimize the maximizing agent\u2019s utility.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/overview/#3-minimax-algorithm","title":"3. Minimax Algorithm","text":"<ul> <li>Purpose: Finds the optimal move in deterministic, perfect-information games.</li> <li>Assumes:</li> <li>The maximizing agent plays optimally.</li> <li>The minimizing agent also plays optimally.</li> <li>Steps:</li> <li>Generate the game tree up to a certain depth.</li> <li>Apply the utility function to terminal nodes.</li> <li>Propagate values back up the tree (min or max at each level).</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/overview/#4-alpha-beta-pruning","title":"4. Alpha-Beta Pruning","text":"<ul> <li>An optimization for the Minimax Algorithm that eliminates branches of the game tree that cannot affect the final decision.</li> <li>Alpha (\u03b1): The best value that the maximizing agent can guarantee.</li> <li>Beta (\u03b2): The best value that the minimizing agent can guarantee.</li> <li>Pruning: Stops evaluating a branch when \u03b1 \u2265 \u03b2.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/overview/#5-evaluation-functions","title":"5. Evaluation Functions","text":"<ul> <li>Used to approximate the utility of a game state when the tree cannot be searched to terminal nodes.</li> <li>Example for chess: A weighted sum of material count, board position, and other heuristics.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/overview/#6-stochastic-games","title":"6. Stochastic Games","text":"<ul> <li>Incorporate chance nodes into the game tree (e.g., dice rolls).</li> <li>Utility is calculated using expected values:</li> <li>Probability-weighted average of possible outcomes.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/overview/#key-algorithms","title":"Key Algorithms","text":"<ol> <li>Minimax Algorithm:</li> <li>Finds optimal moves by considering both players' strategies.</li> <li>Alpha-Beta Pruning:</li> <li>Optimizes Minimax by reducing the number of nodes evaluated.</li> <li>Expectiminimax:</li> <li>Extends Minimax to stochastic games by incorporating chance nodes.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/overview/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Adversarial Search is essential for modeling competitive environments.</li> <li>Minimax provides a foundation for strategic decision-making in games.</li> <li>Alpha-Beta Pruning significantly improves search efficiency.</li> <li>Heuristic evaluation functions are critical for handling complex games where exhaustive search is impractical.</li> <li>Stochastic games require probabilistic reasoning to handle uncertainty.</li> </ol>"},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/","title":"5.1.1 Perfect Information Zero-Sum Games","text":""},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/#overview","title":"Overview","text":"<p>This section focuses on perfect information zero-sum games, a subclass of competitive environments where: 1. Perfect Information: All players have complete knowledge of the game state. 2. Zero-Sum: One player\u2019s gain is another player\u2019s loss.</p> <p>Examples include Chess, Go, and Tic-Tac-Toe, where both players can see the entire game state and take turns making decisions.</p>"},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/#key-components-of-perfect-information-games","title":"Key Components of Perfect Information Games","text":""},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/#1-game-representation","title":"1. Game Representation","text":"<p>A game is modeled using: - Initial State: The starting position of the game. - Players: Typically two competing agents. - Move: A legal action taken by a player. - State Space Graph: A directed graph where nodes represent game states, and edges represent legal moves. - Search Tree: A tree representation of game states explored by an AI agent.</p>"},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/#2-game-progression","title":"2. Game Progression","text":"<ul> <li>Transition Model: Defines how actions change the game state.</li> <li>Terminal State: A state where the game ends (win/loss/draw).</li> <li>Terminal Test: A function that checks whether a state is terminal.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/#3-game-evaluation","title":"3. Game Evaluation","text":"<ul> <li>Utility Function: Assigns a numerical value to terminal states:</li> <li>Win (+1), Loss (-1), Draw (0) in Tic-Tac-Toe.</li> <li>More complex utility values exist in Chess and Go.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/#4-game-trees-vs-search-trees","title":"4. Game Trees vs. Search Trees","text":"<ul> <li>Game Tree: Represents all possible sequences of moves from the initial state.</li> <li>Search Tree: Explored portion of the game tree based on an AI agent's search algorithm.</li> </ul>"},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/#vocabulary-table-for-511","title":"Vocabulary Table for 5.1.1","text":"Term Definition Perfect Information A game where all players have full visibility of the game state. No hidden information exists. Zero-Sum Game A game where one player\u2019s gain equals the other player\u2019s loss. Position The current configuration of the game state at a specific point in play. Move A legal action that transitions the game from one state to another. Initial State The starting position of a game, from which the first move is made. Transition Model A function that defines the result of taking an action in a given state. Terminal Test A function that checks whether the current game state is a terminal state (i.e., the game has ended). Terminal State A game state where no further moves can be made, and the game is over. Utility Function A numerical function that assigns values to terminal states (e.g., Win = 1, Loss = -1, Draw = 0). State Space Graph A graph where nodes represent game states and edges represent moves. Search Tree A tree representation of game states explored during an AI search process. Game Tree A full representation of all possible moves and game states from the initial state onward."},{"location":"courses/intro-to-ai/chapter5/two-player-zero-sum-games/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Perfect information zero-sum games allow for complete visibility of the game state.</li> <li>Utility functions are used to evaluate terminal states numerically.</li> <li>Game trees represent all possible moves, while search trees focus only on explored paths.</li> <li>These principles lay the foundation for AI strategies like Minimax and Alpha-Beta Pruning.</li> </ol>"},{"location":"courses/intro-to-ai/chapter6/6.1.1_variables_domains_constraints/","title":"6.1.1 Variables, Domains, and Constraints","text":"<p>This section explores 6.1.1 variables, domains, and constraints in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.1.1_variables_domains_constraints/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.1.2_csp_examples/","title":"6.1.2 Examples of CSPs","text":"<p>This section explores 6.1.2 examples of csps in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.1.2_csp_examples/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.1_defining_csp/","title":"6.1 Defining Constraint Satisfaction Problems","text":"<p>This section explores 6.1 defining constraint satisfaction problems in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.1_defining_csp/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.2.1_node_consistency/","title":"6.2.1 Node Consistency","text":"<p>This section explores 6.2.1 node consistency in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.2.1_node_consistency/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.2.2_arc_consistency/","title":"6.2.2 Arc Consistency","text":"<p>This section explores 6.2.2 arc consistency in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.2.2_arc_consistency/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.2.3_path_consistency/","title":"6.2.3 Path Consistency","text":"<p>This section explores 6.2.3 path consistency in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.2.3_path_consistency/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.2.4_k_consistency/","title":"6.2.4 k-Consistency","text":"<p>This section explores 6.2.4 k-consistency in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.2.4_k_consistency/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.2.5_global_constraints/","title":"6.2.5 Global Constraints","text":"<p>This section explores 6.2.5 global constraints in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.2.5_global_constraints/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.2.6_sudoku_as_csp/","title":"6.2.6 Sudoku as a CSP","text":"<p>This section explores 6.2.6 sudoku as a csp in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.2.6_sudoku_as_csp/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.2_constraint_propagation/","title":"6.2 Constraint Propagation: Inference in CSPs","text":"<p>This section explores 6.2 constraint propagation: inference in csps in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.2_constraint_propagation/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.3.1_variable_value_ordering/","title":"6.3.1 Variable and Value Ordering","text":"<p>This section explores 6.3.1 variable and value ordering in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.3.1_variable_value_ordering/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.3.2_constraint_learning/","title":"6.3.2 Constraint Learning","text":"<p>This section explores 6.3.2 constraint learning in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.3.2_constraint_learning/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.3.3_intelligent_backtracking/","title":"6.3.3 Intelligent Backtracking","text":"<p>This section explores 6.3.3 intelligent backtracking in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.3.3_intelligent_backtracking/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.3.4_local_search_for_csps/","title":"6.3.4 Local Search for CSPs","text":"<p>This section explores 6.3.4 local search for csps in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.3.4_local_search_for_csps/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.3_backtracking_search/","title":"6.3 Backtracking Search for CSPs","text":"<p>This section explores 6.3 backtracking search for csps in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.3_backtracking_search/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.4.1_tree_structured_csps/","title":"6.4.1 Tree-Structured CSPs","text":"<p>This section explores 6.4.1 tree-structured csps in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.4.1_tree_structured_csps/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.4.2_nearly_tree_structured_csps/","title":"6.4.2 Nearly Tree-Structured CSPs","text":"<p>This section explores 6.4.2 nearly tree-structured csps in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.4.2_nearly_tree_structured_csps/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.4.3_cutset_conditioning/","title":"6.4.3 Cutset Conditioning","text":"<p>This section explores 6.4.3 cutset conditioning in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.4.3_cutset_conditioning/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.4_structure_of_csps/","title":"6.4 The Structure of Constraint Satisfaction Problems","text":"<p>This section explores 6.4 the structure of constraint satisfaction problems in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.4_structure_of_csps/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.5.1_scheduling_problems/","title":"6.5.1 Scheduling Problems","text":"<p>This section explores 6.5.1 scheduling problems in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.5.1_scheduling_problems/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.5.2_cryptarithmetic_logic_puzzles/","title":"6.5.2 Cryptarithmetic and Logic Puzzles","text":"<p>This section explores 6.5.2 cryptarithmetic and logic puzzles in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.5.2_cryptarithmetic_logic_puzzles/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.5.3_resource_allocation/","title":"6.5.3 Resource Allocation","text":"<p>This section explores 6.5.3 resource allocation in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.5.3_resource_allocation/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/chapter6/6.5_real_world_applications/","title":"6.5 Real-World Applications of CSPs","text":"<p>This section explores 6.5 real-world applications of csps in artificial intelligence.</p>"},{"location":"courses/intro-to-ai/chapter6/6.5_real_world_applications/#key-concepts","title":"Key Concepts","text":"<ul> <li>Explanation of the topic</li> <li>Examples</li> <li>Algorithms</li> </ul> <pre><code>graph TD;\n  A[Start] --&gt; B[Process] --&gt; C[End]</code></pre>"},{"location":"courses/intro-to-ai/resources/useful-links/","title":"AI Study Resources (Weekly)","text":""},{"location":"courses/intro-to-ai/resources/useful-links/#week-1-search-algorithms","title":"Week 1: Search Algorithms","text":"Topic Source Link Search Algorithms Geeks for Geeks Search Algorithms in AI Search Algorithms Medium AI Search Algorithms Every Data Scientist Should Know Search Algorithms Scaler Search Algorithms in Artificial Intelligence Search Algorithms Tutorials Point AI - Popular Search Algorithms Search Algorithms Analytics Vidhya An Introduction to Problem-Solving using Search Algorithms for Beginners Search Algorithms Simplilearn A* Search Algorithm Explained: Applications &amp; Uses Search Algorithms Medium AI Search Algorithms With Examples"},{"location":"courses/intro-to-ai/resources/useful-links/#week-2-adversarial-search--csp","title":"Week 2: Adversarial Search &amp; CSP","text":""},{"location":"courses/intro-to-ai/resources/useful-links/#adversarial-search","title":"Adversarial Search","text":"Topic Source Link Adversarial Search Geeks for Geeks Adversarial Search Algorithms in AI Adversarial Search Geeks for Geeks Role of Minimax Algorithm in Adversarial Search"},{"location":"courses/intro-to-ai/resources/useful-links/#constraint-satisfaction-problems-csp","title":"Constraint Satisfaction Problems (CSP)","text":"Topic Source Link Constraint Satisfaction Problems Geeks for Geeks Constraint Satisfaction Problems (CSP) in AI Constraint Satisfaction Problems Hero Vired CSP Algorithm &amp; Examples Constraint Satisfaction Problems Geeks for Geeks Constraint Propagation in AI"}]}