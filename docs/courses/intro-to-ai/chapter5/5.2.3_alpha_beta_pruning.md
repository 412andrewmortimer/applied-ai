# **ðŸ“– 5.2.3 Alphaâ€“Beta Pruning**

## **ðŸ“Œ Introduction**
In the previous sections, we explored the **Minimax Algorithm** for making optimal decisions in two-player zero-sum games. However, **Minimax has a major weakness**: it evaluates **all possible moves**, which becomes computationally expensive for large games like Chess or Go.

**Alpha-Beta Pruning** is an **optimization** technique for Minimax that significantly reduces the number of nodes **that need to be evaluated**, making Minimax **faster** without affecting the final decision.

### **âœ… Why Use Alpha-Beta Pruning?**
âœ” **Reduces the number of nodes that must be explored**.  
âœ” **Maintains the same optimal decision as Minimax**.  
âœ” **Speeds up decision-making in complex games like Chess**.  
âœ” **Efficiently searches deeper levels in the game tree**.  

---

## **ðŸ”¹ What is Alpha-Beta Pruning?**
Alpha-Beta Pruning **eliminates branches in the game tree that wonâ€™t influence the final decision**. It uses two values:
- **Alpha (Î±)**: The **best value MAX can guarantee** so far.
- **Beta (Î²)**: The **best value MIN can guarantee** so far.

During the Minimax search:
- **If MIN finds a move worse than an already evaluated option, it stops searching that branch.**  
- **If MAX finds a move better than an already evaluated option, it stops searching that branch.**  

âœ… **This saves time by avoiding unnecessary calculations**.

---

## **ðŸ”¹ Alpha-Beta Pruning Algorithm Steps**
1. **Set Î± = -âˆž (worst for MAX) and Î² = +âˆž (worst for MIN).**
2. **Traverse the game tree using Minimax.**
3. **At each node:**
   - **If MAX finds a move better than Î²**, **stop evaluating** that branch (**prune**).
   - **If MIN finds a move worse than Î±**, **stop evaluating** that branch (**prune**).
4. **Continue the search while updating Î± and Î² values dynamically.**
5. **Return the best possible move for MAX.**

---

## **ðŸ”¹ Alpha-Beta Pruning Pseudocode**
Here is a **recursive implementation** of **Alpha-Beta Pruning**:

```python
def alphabeta(state, depth, alpha, beta, is_maximizing):
    if is_terminal(state) or depth == 0:
        return evaluate(state)

    if is_maximizing:
        best_value = -float("inf")
        for move in get_possible_moves(state):
            new_state = apply_move(state, move)
            value = alphabeta(new_state, depth - 1, alpha, beta, False)
            best_value = max(best_value, value)
            alpha = max(alpha, best_value)  # Update Î±

            if beta <= alpha:  # Beta Cutoff (Prune)
                break
        return best_value

    else:  # Minimizing Player (MIN)
        best_value = float("inf")
        for move in get_possible_moves(state):
            new_state = apply_move(state, move)
            value = alphabeta(new_state, depth - 1, alpha, beta, True)
            best_value = min(best_value, value)
            beta = min(beta, best_value)  # Update Î²

            if beta <= alpha:  # Alpha Cutoff (Prune)
                break
        return best_value
```

âœ… **What this does:**  
- **Updates Î± (MAXâ€™s best move) and Î² (MINâ€™s best move) dynamically**.  
- **Prunes branches when Î² â‰¤ Î±** (no need to explore further).  
- **Ensures the same optimal move as Minimax but faster**.  

---

## **ðŸ”¹ Time Complexity of Alpha-Beta Pruning**
| **Algorithm**          | **Time Complexity** | **Explored Nodes** |
|------------------------|-------------------|------------------|
| **Minimax**           | O(b^d)            | **Explores all nodes** |
| **Alpha-Beta Pruning** | O(b^(d/2))        | **Explores fewer nodes** |

âœ… **Why is Alpha-Beta Pruning Faster?**
- Pruning **eliminates branches that wonâ€™t influence the final decision**.
- Allows the **AI to search deeper** in the same amount of time.

---

## **ðŸ”¹ Strengths & Weaknesses of Alpha-Beta Pruning**
### âœ… **Advantages**
âœ” **Significantly reduces computation time** compared to Minimax.  
âœ” **Allows deeper searches** in complex games like Chess.  
âœ” **Still finds the same optimal move as Minimax**.  

### âŒ **Disadvantages**
âœ– **Does not work well if moves are unordered** (bad ordering reduces pruning).  
âœ– **Still exponential complexity** (O(b^(d/2)), but better than O(b^d)).  
âœ– **Limited usefulness in non-zero-sum games** (e.g., Poker).  

---

## **ðŸ”¹ Key Takeaways**
âœ” **Alpha-Beta Pruning speeds up Minimax without changing the final decision**.  
âœ” **Pruning occurs when we find a move that makes further search unnecessary**.  
âœ” **The best case occurs when moves are sorted from best to worst**.  
âœ” **Allows AI to play games like Chess and Go more efficiently**.  

---

## **ðŸ“š Next Steps**
- Implement **Alpha-Beta Pruning for Tic-Tac-Toe or Chess AI**.  
- Learn **Move Ordering techniques** to improve pruning efficiency.  
- Explore **Monte Carlo Tree Search (MCTS) as an alternative to Minimax**.  

âœ… **Would you like a Python implementation of Alpha-Beta Pruning for Chess?** ðŸš€  
